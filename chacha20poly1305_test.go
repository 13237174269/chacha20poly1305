package chacha20poly1305

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"testing"
)

// stolen from http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-00#section-7
var testVectors = [][]string{
	[]string{
		"e3c37ba4984da482b4f978f314b149857f4f3027470bced382ad92889ed4fcb6",
		"1400000cbe2f24b0b1bf5276fc91a9ad",
		"0000000000000000",
		"00000000000000001603030010",
		"46d4b8cfb0323dcad49cafe58ad009602fe190ebb314ddab20e541fdb7b7541c",
	},
}

func TestSealing(t *testing.T) {
	for i, vector := range testVectors {
		t.Logf("Running test vector %d", i)

		key, err := hex.DecodeString(vector[0])
		if err != nil {
			t.Error(err)
		}

		plaintext, err := hex.DecodeString(vector[1])
		if err != nil {
			t.Error(err)
		}

		nonce, err := hex.DecodeString(vector[2])
		if err != nil {
			t.Error(err)
		}

		data, err := hex.DecodeString(vector[3])
		if err != nil {
			t.Error(err)
		}

		expected, err := hex.DecodeString(vector[4])
		if err != nil {
			t.Error(err)
		}

		c, err := NewChaCha20Poly1305(key)
		if err != nil {
			t.Error(err)
		}

		actual := c.Seal(nil, nonce, plaintext, data)

		if !bytes.Equal(expected, actual) {
			t.Errorf("Bad seal: expected %x, was %x", expected, actual)

			for i, v := range expected {
				if actual[i] != v {
					t.Logf("Mismatch at offset %d: %x vs %x", i, v, actual[i])
					break
				}
			}
		}
	}
}

func TestRoundtrip(t *testing.T) {
	key := make([]byte, 32)
	nonce := make([]byte, 8)

	c, err := NewChaCha20Poly1305(key)
	if err != nil {
		t.Error(err)
	}

	plaintext := []byte("yay for me")
	data := []byte("whoah yeah")
	ciphertext := c.Seal(nil, nonce, plaintext, data)

	actual, err := c.Open(nil, nonce, ciphertext, data)
	if err != nil {
		t.Error(err)
	}

	if !bytes.Equal(plaintext, actual) {
		t.Errorf("Bad seal: expected %x, was %x", plaintext, actual)
	}
}

func TestModifiedData(t *testing.T) {
	key := make([]byte, 32)
	nonce := make([]byte, 8)

	c, err := NewChaCha20Poly1305(key)
	if err != nil {
		t.Error(err)
	}

	plaintext := []byte("yay for me")
	data := []byte("whoah yeah")
	ciphertext := c.Seal(nil, nonce, plaintext, data)

	data[0] ^= 1

	_, err = c.Open(nil, nonce, ciphertext, data)
	if err != ErrAuthFailed {
		t.Error("Should have failed, but didn't")
	}
}

func TestModifiedCiphertext(t *testing.T) {
	key := make([]byte, 32)
	nonce := make([]byte, 8)

	c, err := NewChaCha20Poly1305(key)
	if err != nil {
		t.Error(err)
	}

	plaintext := []byte("yay for me")
	data := []byte("whoah yeah")
	ciphertext := c.Seal(nil, nonce, plaintext, data)

	ciphertext[0] ^= 1

	_, err = c.Open(nil, nonce, ciphertext, data)
	if err != ErrAuthFailed {
		t.Error("Should have failed, but didn't")
	}
}

func BenchmarkChaCha20Poly1305(b *testing.B) {
	key := make([]byte, 32)
	nonce := make([]byte, 8)
	c, err := NewChaCha20Poly1305(key)
	if err != nil {
		panic(err)
	}

	input := make([]byte, 1024*1024)

	b.SetBytes(int64(len(input)))
	for i := 0; i < b.N; i++ {
		c.Seal(nil, nonce, input, nil)
	}
}

func ExampleNewChaCha20Poly1305() {
	key := make([]byte, 32)  // this should be secret
	nonce := make([]byte, 8) // this should be randomly generated by crypto/rand

	c, err := NewChaCha20Poly1305(key)
	if err != nil {
		panic(err)
	}

	plaintext := []byte("yay for me")
	data := []byte("whoah yeah")
	ciphertext := c.Seal(nil, nonce, plaintext, data)

	fmt.Printf("%x\n", ciphertext)
	// Output:
	// e6669e9e333e4a5af5df32dd1c232712994c7c7796126e91a2ad
}
